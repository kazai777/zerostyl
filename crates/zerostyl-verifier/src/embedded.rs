//! Embedded verification key and parameters
//!
//! When the `embedded_vk` feature is enabled, VK and params are embedded
//! at compile time via build.rs generated include files.

#[cfg(not(feature = "std"))]
use alloc::vec::Vec;

use halo2_proofs::poly::commitment::Params;
use halo2curves::pasta::EqAffine;

// Include the generated embedded keys from build.rs
include!(concat!(env!("OUT_DIR"), "/embedded_keys.rs"));

type VerifyError = Vec<u8>;

/// Get the raw embedded VK bytes
pub fn embedded_vk_bytes() -> &'static [u8] {
    VK_BYTES
}

/// Get the raw embedded params bytes
pub fn embedded_params_bytes() -> &'static [u8] {
    PARAMS_BYTES
}

/// Load the embedded commitment parameters
pub fn load_embedded_params() -> Result<Params<EqAffine>, VerifyError> {
    if PARAMS_BYTES.is_empty() {
        return Err(Vec::from(b"Embedded params are empty"));
    }

    Params::read(&mut &PARAMS_BYTES[..]).map_err(|e| {
        let msg = format!("Failed to deserialize embedded params: {:?}", e);
        Vec::from(msg.as_bytes())
    })
}

/// Get the circuit size parameter k
pub fn embedded_k() -> u32 {
    K
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_embedded_k() {
        assert_eq!(embedded_k(), 10);
    }

    #[test]
    fn test_embedded_params_bytes_not_empty() {
        // Params should always be generated by build.rs when embedded_vk is enabled
        assert!(!embedded_params_bytes().is_empty());
    }

    #[test]
    fn test_load_embedded_params() {
        let result = load_embedded_params();
        assert!(result.is_ok(), "Failed to load embedded params: {:?}", result.err());
    }

    #[test]
    fn test_embedded_vk_bytes() {
        // VK bytes may be empty if extract-vk-v2 hasn't been run
        // Just verify the function works
        let _bytes = embedded_vk_bytes();
    }
}
